<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#3b82f6" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#1e3a8a" media="(prefers-color-scheme: dark)">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Nebulae">
    
    <!-- PWA Icons -->
    <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
    <link rel="apple-touch-icon" href="{{ url_for('static', filename='icons/icon-192x192.png') }}">
    <link rel="icon" type="image/png" sizes="192x192" href="{{ url_for('static', filename='icons/icon-192x192.png') }}">
    <link rel="icon" type="image/png" sizes="512x512" href="{{ url_for('static', filename='icons/icon-512x512.png') }}">
    <title>Browse Media</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <style>
        /* This part stays in the HTML because it's dynamically generated by the server */
        html {
            font-size: {{ user_settings.text_size | default(100) }}%;
        }
    </style>
    <script>
        // Immediately apply the theme to prevent flashing
        (function() {
            const theme = "{{ user_settings.theme | default('light') }}";
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            }
        })();
    </script>
</head>
<body class="flex flex-col min-h-screen items-center py-8 px-4">
    <div class="max-w-4xl w-full p-8 rounded-lg shadow-xl border main-container">
        <h1 class="text-3xl font-bold text-center mb-6 primary-text">Browse Media</h1>

        <!-- Flash Messages -->
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <div class="mb-4">
                    {% for category, message in messages %}
                        <div class="flash-message flash-{{ category }}">{{ message }}</div>
                    {% endfor %}
                </div>
            {% endif %}
        {% endwith %}

        {% if user_media_path %}
            <div class="mb-8 text-center">
                <button type="button" id="select-media-button" onclick="sendSelectedMediaToParent()" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out" disabled>
                    Select Media & Close
                </button>
            </div>

            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold primary-text">Current Folder: /{{ current_subfolder if current_subfolder else ' (Root)' }}</h2>
                    {% if current_subfolder %}
                        {% set parent_path = current_subfolder.rsplit('/', 1)[0] if '/' in current_subfolder else '' %}
                        {% if parent_path %}
                            {% set back_url = url_for('main.browse_media', subfolder=parent_path, mode=request.args.get('mode'), post_id=request.args.get('post_id'), comment_id=request.args.get('comment_id'), post_cuid=request.args.get('post_cuid')) %}
                        {% else %}
                            {% set back_url = url_for('main.browse_media', mode=request.args.get('mode'), post_id=request.args.get('post_id'), comment_id=request.args.get('comment_id'), post_cuid=request.args.get('post_cuid')) %}
                        {% endif %}
                        
                        <button type="button" onclick="navigateToFolder('{{ back_url | js_string }}')" class="bg-gray-300 hover:bg-gray-400 text-gray-800 dark:bg-gray-600 dark:hover:bg-gray-500 dark:text-gray-200 font-semibold py-2 px-4 rounded-lg shadow-sm transition duration-300 ease-in-out">
                            Back to Parent Folder
                        </button>
                    {% endif %}
            </div>

            <div class="mb-6">
                {% if directories %}
                    <h3 class="text-lg font-medium mb-2 primary-text">Folders:</h3>
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        {% for dir in directories %}
                            {# Changed to use JavaScript for navigation to preserve selectedMedia #}
                            <button type="button" onclick="navigateToFolder('{{ url_for('main.browse_media', subfolder=current_subfolder + '/' + dir if current_subfolder else dir, mode=request.args.get('mode'), post_id=request.args.get('post_id'), comment_id=request.args.get('comment_id'), post_cuid=request.args.get('post_cuid')) | js_string }}')"
                               class="folder-item">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                                </svg>
                                <span class="primary-text font-medium truncate">{{ dir }}</span>
                            </button>
                        {% endfor %}
                    </div>
                {% else %}
                    <p class="secondary-text">No subfolders in this directory.</p>
                {% endif %}
            </div>

            <div>
                <h3 class="text-lg font-medium mb-2 primary-text">Media Files:</h3>
                {% if media_files %}
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        {% for media_file_path in media_files %}
                            {# PUID FIX: Use the current_user_puid passed from the route #}
                            {% set full_media_url = url_for('serve_user_media', puid=current_user_puid, filename=media_file_path) %}
                            {% set media_type = 'image' if media_file_path.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.webp')) else ('video' if media_file_path.lower().endswith(('.mp4', '.mov', '.webm', '.avi', '.mkv')) else 'other') %}

                            {# Conditionally render media item based on mode #}
                            {% if is_single_select and media_type == 'video' %}
                                {# Skip video files if in single_select mode #}
                            {% else %}
                                <div class="media-item w-full h-40 rounded-lg overflow-hidden shadow-md"
                                     data-path="{{ media_file_path }}"
                                     onclick="toggleMediaSelection(this)">
                                    {# Check file extension case-insensitively #}
                                    {% if media_type == 'image' %}
                                        <img src="{{ full_media_url }}" alt="{{ media_file_path.split('/')[-1] }}">
                                    {% elif media_type == 'video' %}
                                        <video playsinline preload="metadata" muted> {# Added playsinline, preload="metadata", muted #}
                                            <source src="{{ full_media_url }}#t=0.1" type="video/mp4">
                                            Your browser does not support the video tag.
                                        </video>
                                    {% else %}
                                        <div class="w-full h-full flex items-center justify-center bg-gray-200 text-gray-500 text-center text-sm">
                                            Unsupported: {{ media_file_path.split('/')[-1] }}
                                        </div>
                                    {% endif %}
                                    <div class="overlay">
                                        <span class="check-icon">&#10003;</span> <!-- Checkmark icon -->
                                    </div>
                                </div>
                            {% endif %}
                        {% endfor %}
                    </div>
                {% else %}
                    <p class="text-center secondary-text">No media files in this directory.</p>
                {% endif %}
            </div>
        {% else %}
            <p class="text-center flash-warning">{{ error_message }}</p>
        {% endif %}
    </div>

    <!-- Custom Message Modal -->
    <div id="customMessageModal" class="custom-message-modal">
        <div class="custom-message-modal-content">
            <p id="customMessageContent" class="text-lg font-semibold primary-text mb-4"></p>
            <button onclick="closeCustomMessageModal()" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg">OK</button>
        </div>
    </div>

    <script>
        let selectedMedia = []; // Stores relative paths of selected media files
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode');
        const postId = urlParams.get('post_id'); // For newComment
        const commentId = urlParams.get('comment_id'); // For editComment
        const postCuid = urlParams.get('post_cuid'); // For editPost
        const isSingleSelectMode = mode === 'single_select';

        // Custom message box functions
        function showCustomMessage(message) {
            document.getElementById('customMessageContent').textContent = message;
            document.getElementById('customMessageModal').style.display = 'flex'; // Use flex to center
        }

        function closeCustomMessageModal() {
            document.getElementById('customMessageModal').style.display = 'none';
        }

        // Initialize selectedMedia from URL parameter if provided
        document.addEventListener('DOMContentLoaded', () => {
            const selectedParam = urlParams.get('selected');
            if (selectedParam) {
                try {
                    const initialSelection = JSON.parse(decodeURIComponent(selectedParam));
                    if (Array.isArray(initialSelection)) {
                        selectedMedia = initialSelection.map(item => {
                            return typeof item === 'object' && item !== null && item.media_file_path ? item.media_file_path : item;
                        });
                    }
                    
                    selectedMedia.forEach(path => {
                        const item = document.querySelector(`.media-item[data-path="${path}"]`);
                        if (item) {
                            item.classList.add('selected');
                        }
                    });
                } catch (e) {
                    console.error("browse_media.html: Error parsing selected media from URL:", e);
                    selectedMedia = [];
                }
            }
            updateSelectButtonState();
        });

        function toggleMediaSelection(element) {
            const mediaPath = element.dataset.path;
            if (isSingleSelectMode) {
                selectedMedia.forEach(path => {
                    const prevItem = document.querySelector(`.media-item[data-path="${path}"]`);
                    if (prevItem) prevItem.classList.remove('selected');
                });
                selectedMedia = [mediaPath];
                element.classList.add('selected');
            } else {
                if (selectedMedia.includes(mediaPath)) {
                    selectedMedia = selectedMedia.filter(path => path !== mediaPath);
                    element.classList.remove('selected');
                } else {
                    selectedMedia.push(mediaPath);
                    element.classList.add('selected');
                }
            }
            updateSelectButtonState();
        }

        function updateSelectButtonState() {
            const selectButton = document.getElementById('select-media-button');
            if (selectButton) {
                selectButton.disabled = selectedMedia.length === 0;
                if (isSingleSelectMode) {
                    selectButton.textContent = selectedMedia.length === 1 ? 'Select Picture' : 'Select a Picture';
                } else {
                    selectButton.textContent = `Add Selected Media (${selectedMedia.length})`;
                }
            }
        }

        function navigateToFolder(baseUrl) {
            const currentSelected = encodeURIComponent(JSON.stringify(selectedMedia));
            let url = baseUrl;
            
            // Re-add all relevant URL parameters
            if (mode) url += (url.includes('?') ? '&' : '?') + 'mode=' + mode;
            if (postId) url += (url.includes('?') ? '&' : '?') + 'post_id=' + postId;
            if (commentId) url += (url.includes('?') ? '&' : '?') + 'comment_id=' + commentId;
            if (postCuid) url += (url.includes('?') ? '&' : '?') + 'post_cuid=' + postCuid;
            if (selectedMedia.length > 0) url += (url.includes('?') ? '&' : '?') + 'selected=' + currentSelected;
            
            window.location.href = url;
        }

        function sendSelectedMediaToParent() {
            const mediaArrayWithObjects = selectedMedia.map(path => ({
                media_file_path: path,
                alt_text: ''
            }));

            // Reliably determine the mode.
            // First, try sessionStorage, which works for same-origin.
            let openerMode = sessionStorage.getItem('mediaBrowserMode');

            // If sessionStorage is null (which happens in the cross-origin 'create post' case),
            // infer the mode from the URL parameters. This is our robust fallback.
            if (!openerMode) {
                console.log("browse_media.html: No sessionStorage mode found (likely cross-origin). Inferring from URL params.");
                if (isSingleSelectMode) {
                    openerMode = 'single_select';
                } else if (mode === 'multi_select') {
                    // Check in order of specificity
                    if (postCuid) {
                        openerMode = 'editPost';
                    } else if (commentId) { 
                        openerMode = 'editComment';
                    } else if (postId) { 
                        openerMode = 'newComment';
                    } else {
                        // Default for multi_select if no other IDs are present
                        openerMode = 'createPost'; 
                    }
                } else {
                    // Fallback just in case mode is something else
                    openerMode = mode;
                }
            }

            // Determine the correct context ID based on the *actual* mode
            let contextIdForPayload = null;
            if (openerMode === 'editPost') {
                contextIdForPayload = postCuid;
            } else if (openerMode === 'editComment') {
                contextIdForPayload = commentId;
            } else if (openerMode === 'newComment') {
                contextIdForPayload = postId;
            }
            // For 'createPost' and 'single_select', contextIdForPayload remains null, which is correct.
            
            const payload = {
                mode: openerMode,
                selectedMedia: mediaArrayWithObjects,
                contextId: contextIdForPayload
            };

            // Use window.opener.postMessage for cross-origin communication,
            // with BroadcastChannel as a fallback for same-origin.
            if (window.opener && !window.opener.closed) {
                // The targetOrigin should ideally be the specific URL of the opener.
                // Using '*' is simpler but less secure.
                window.opener.postMessage(payload, '*');
                console.log('browse_media.html: Sent message via window.opener.postMessage', payload);
            } else {
                // Fallback for cases where the opener is not available or is same-origin
                try {
                    const mediaSelectionChannel = new BroadcastChannel('media_selection_channel');
                    mediaSelectionChannel.postMessage(payload);
                    console.log('browse_media.html: Sent message via BroadcastChannel', payload);
                    mediaSelectionChannel.close();
                } catch (e) {
                    console.error("browse_media.html: BroadcastChannel failed.", e);
                }
            }
            
            setTimeout(() => {
                window.close();
            }, 100);
        }
    </script>
</body>
</html>